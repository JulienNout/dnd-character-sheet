diff --git a/ARCHITECTURE.md b/ARCHITECTURE.md
index be5348f..3cc2efa 100644
--- a/ARCHITECTURE.md
+++ b/ARCHITECTURE.md
@@ -7,16 +7,36 @@ This D&D 5e Character Sheet application follows Domain-Driven Design (DDD) princ
 ### 1. Domain Layer (`internal/domain/`)
 The core business logic with zero external dependencies.
 
-- **`character/character.go`**: Pure domain model
+#### Character Entity (`character/`)
+- **`character.go`**: Pure domain model
   - `Character` struct with business rules
   - `ComputeModifiers()`: ability score modifiers
   - `ComputeDerived()`: default derived stats (minimal, extensible)
   - `ApplyRacialBonuses()`: racial stat bonuses
   - `GetProficiencyBonus()`: proficiency by level
 
+#### Spellcasting Entity (`spellcasting/`)
+- **`spellcasting.go`**: Spellcasting domain model
+  - `Spellcasting` struct with CasterType, KnownSpells, PreparedSpells, SpellSlots
+  - `NewSpellcasting(class, level)`: creates spellcasting for a character
+  - `LearnSpell(spellName)`: adds to known spells (prevents duplicates)
+  - `PrepareSpell(spellName)`: adds to prepared spells (requires known, prevents duplicates)
+  - Domain errors: `ErrSpellNotKnown`, `ErrSpellAlreadyPrepared`
+
+- **`rules.go`**: Spellcasting business rules
+  - `GetCasterType(class)`: determines caster progression (full/half/pact/known/none)
+  - `GetSpellSlots(casterType, level)`: returns spell slots by level
+  - `GetCantripsKnown(class, level)`: cantrips available per class/level
+  - Spell slot tables for full/half/pact casters
+
+#### Reference Data (`background/`, `class/`)
+- **`background/model.go`**: Background definitions with skill proficiencies
+- **`class/model.go`**: Class definitions with skill counts and proficiencies
+
 **Rules:**
-- No imports from other layers
+- No imports from other layers (no ports, adapters, application)
 - Pure business logic only
+- No JSON tags or infrastructure concerns
 - Immutable where possible
 
 ### 2. Application Layer (`internal/application/`)
@@ -50,6 +70,11 @@ Defines interfaces (contracts) for external systems.
   - `AssignSpellcasting`, `LearnSpell`, `PrepareSpell`
   - `FormatSpellSlots`, `FormatCantrips`
 
+- **`spell_repository.go`**: Spell data access contract
+  - `LoadSpells()`: loads all spell data
+  - `FilterByClass(spells, class)`: filters spells for a class
+  - `Spell` type with Index, Name, Level, Classes
+
 **Rules:**
 - Interfaces only (no implementations)
 - Defines contracts for adapters
@@ -60,52 +85,52 @@ Implements ports using specific technologies.
 
 #### Storage Adapter (`adapters/storage/`)
 - **`repository.go`**: Implements `CharacterRepository` port
-  - Maps between domain `Character` and storage `Character`
-  - Delegates to `internal/storage` backend
+  - Maps between domain `Character` and storage model
+  - `unmarshalSpellcasting()`: reconstructs typed spellcasting from JSON
+  - Delegates to `jsonstorage/` backend
+
+- **`jsonstorage/`**: JSON file storage implementation
+  - `model.go`: storage types (`Character`, `CharacterSummary`, `CharacterStorage` interface)
+  - `single_file_storage.go`: JSON file CRUD operations
+  - No domain knowledge, pure infrastructure
+
+- **`repository_spellcasting_test.go`**: Tests spellcasting persistence round-trip
 
 #### API Adapter (`adapters/api/`)
 - **`client_adapter.go`**: Implements enricher ports
-  - `APIAdapter` calls D&D 5e REST API
+  - `APIAdapter` calls D&D 5e REST API (configurable base URL)
   - `GetWeapon`, `GetArmor`, `GetSpell` methods
-  - Configurable base URL
+  - Implements `WeaponEnricher`, `ArmorEnricher`, `SpellEnricher`
 
 #### Spellcasting Adapter (`adapters/spellcasting/`)
 - **`engine_adapter.go`**: Implements `SpellcastingEngine` port
-  - Temporary bridge to legacy CSV-based spellcasting
-  - Formats spell slots and cantrips for display
-
-**Rules:**
-- Implements port interfaces
-- Contains technology-specific code
-- No business logic
-
-### 5. Infrastructure (`internal/storage/`)
-Low-level persistence implementation.
+  - Uses domain `spellcasting.NewSpellcasting()` for initialization
+  - Uses domain `LearnSpell()` and `PrepareSpell()` methods
+  - Validates spells via `SpellRepository` (CSV)
+  - Formats spell slots and cantrips for display using domain rules
 
-- **`model.go`**: Storage types
-  - `Character`: JSON persistence schema
-  - `CharacterSummary`: list view
-  - `CharacterStorage`: storage interface
-
-- **`single_file_storage.go`**: File-based storage
-  - JSON file operations
-  - CRUD for characters
+- **`spell_repository.go`**: Implements `SpellRepository` port
+  - `CSVSpellRepository`: loads spells from CSV file
+  - Filters spells by class
+  - Pure infrastructure (CSV parsing)
 
 **Rules:**
-- Owned by adapters (not directly used by application)
-- Storage-specific concerns only
+- Implements port interfaces
+- Contains technology-specific code (HTTP, JSON, CSV)
+- No business logic (delegates to domain)
 
-### 6. Presentation Layer (`main.go`)
+### 5. Presentation Layer (`main.go`)
 CLI interface - the outer layer.
 
 - Command parsing (create, view, list, delete, equip, learn-spell, prepare-spell)
-- Calls application service
-- Displays results
+- Wires dependencies: creates adapters (storage, API, spellcasting), injects into application service
+- Calls application service for all operations
+- Displays results (including type-asserting domain spellcasting for known/prepared spell display)
 
 **Rules:**
 - Only depends on application service and adapters
 - No direct domain manipulation
-- Wires dependencies (DI)
+- Wires dependencies (Dependency Injection)
 
 ## Dependency Flow
 
@@ -130,24 +155,71 @@ storage/, external APIs
 3. **Dependency Injection**: main.go wires concrete implementations
 4. **Open/Closed Principle**: Add features by implementing new ports/adapters without changing existing code
 
+## Folder Structure
+
+```
+internal/
+├── domain/                       ← Core business logic (no external deps)
+│   ├── character/
+│   │   └── character.go         ← Character entity with business rules
+│   ├── spellcasting/
+│   │   ├── spellcasting.go      ← Spellcasting entity (learn/prepare logic)
+│   │   ├── rules.go             ← Caster types, slot tables, cantrips
+│   │   └── spellcasting_test.go ← Domain unit tests
+│   ├── background/
+│   │   └── model.go             ← Background reference data
+│   └── class/
+│       └── model.go             ← Class reference data
+│
+├── application/                  ← Use case orchestration
+│   ├── character_service.go     ← CRUD, equipment, spells, derived stats
+│   └── character_builder.go     ← Skill combining logic
+│
+├── ports/                        ← Interface contracts
+│   ├── character_repository.go  ← Persistence port
+│   ├── enrichers.go             ← Equipment/spell data ports
+│   ├── spellcasting.go          ← Spellcasting engine port
+│   └── spell_repository.go      ← Spell data access port
+│
+└── adapters/                     ← Infrastructure implementations
+    ├── storage/
+    │   ├── repository.go        ← CharacterRepository implementation
+    │   ├── repository_test.go   ← CRUD tests
+    │   ├── repository_spellcasting_test.go  ← Round-trip tests
+    │   └── jsonstorage/
+    │       ├── model.go         ← Storage schema
+    │       └── single_file_storage.go  ← JSON file backend
+    ├── api/
+    │   ├── client_adapter.go    ← D&D 5e API enrichers
+    │   └── client_adapter_test.go
+    └── spellcasting/
+        ├── engine_adapter.go    ← Spellcasting engine (domain + CSV)
+        └── spell_repository.go  ← CSV spell loader
+```
+
 ## Legacy Code Status
 
 **Removed (refactored into DDD layers):**
 - ✅ `internal/combat` → `application/character_service.RecalculateDerived`
 - ✅ `internal/equipment` → `adapters/api/client_adapter`
+- ✅ `internal/character` → `domain/character` + `application/character_builder`
+- ✅ `internal/api` → `adapters/api/client_adapter`
+- ✅ `internal/spellcasting` → `domain/spellcasting` (rules/entity) + `adapters/spellcasting` (CSV/engine)
+- ✅ `internal/storage` → `adapters/storage/jsonstorage`
+- ✅ `internal/background` → `domain/background`
+- ✅ `internal/class` → `domain/class`
 
-**Remaining (to be addressed):**
-- `internal/spellcasting`: Bridged via adapter; can be replaced with domain-based engine
-- `internal/character`: Legacy storage model (minimal usage remaining)
-- `internal/api`: Legacy API client (overlaps with adapters/api)
-- `internal/background`, `internal/class`: Data loaders (low priority)
+**Result:** Clean DDD/Onion structure with all code in appropriate layers.
 
 ## Testing Strategy
 
 - **Domain**: Pure unit tests (no mocks needed)
+  - `spellcasting_test.go`: tests learn/prepare logic and edge cases
 - **Application**: Test with mock ports
 - **Adapters**: Integration tests with real/mock external systems
-- **Storage adapter**: CRUD test with temp file (`repository_test.go`)
+  - `repository_test.go`: CRUD with temp file
+  - `repository_spellcasting_test.go`: spellcasting persistence round-trip
+  - `client_adapter_test.go`: API calls (requires local server)
 
 ## Next Steps
 
diff --git a/assignment-3.html b/assignment-3.html
new file mode 100644
index 0000000..51bff52
--- /dev/null
+++ b/assignment-3.html
@@ -0,0 +1,258 @@
+<!DOCTYPE html>
+        <html>
+        <head>
+            <meta charset="UTF-8">
+            <title>Modern Programming Practices - Exam</title>
+            <style>
+/* From extension vscode.github */
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+
+.vscode-dark img[src$=\#gh-light-mode-only],
+.vscode-light img[src$=\#gh-dark-mode-only],
+.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
+.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
+	display: none;
+}
+
+</style>
+            
+        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
+<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
+<style>
+            body {
+                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
+                font-size: 14px;
+                line-height: 1.6;
+            }
+        </style>
+        <style>
+.task-list-item {
+    list-style-type: none;
+}
+
+.task-list-item-checkbox {
+    margin-left: -20px;
+    vertical-align: middle;
+    pointer-events: none;
+}
+</style>
+<style>
+:root {
+  --color-note: #0969da;
+  --color-tip: #1a7f37;
+  --color-warning: #9a6700;
+  --color-severe: #bc4c00;
+  --color-caution: #d1242f;
+  --color-important: #8250df;
+}
+
+</style>
+<style>
+@media (prefers-color-scheme: dark) {
+  :root {
+    --color-note: #2f81f7;
+    --color-tip: #3fb950;
+    --color-warning: #d29922;
+    --color-severe: #db6d28;
+    --color-caution: #f85149;
+    --color-important: #a371f7;
+  }
+}
+
+</style>
+<style>
+.markdown-alert {
+  padding: 0.5rem 1rem;
+  margin-bottom: 16px;
+  color: inherit;
+  border-left: .25em solid #888;
+}
+
+.markdown-alert>:first-child {
+  margin-top: 0
+}
+
+.markdown-alert>:last-child {
+  margin-bottom: 0
+}
+
+.markdown-alert .markdown-alert-title {
+  display: flex;
+  font-weight: 500;
+  align-items: center;
+  line-height: 1
+}
+
+.markdown-alert .markdown-alert-title .octicon {
+  margin-right: 0.5rem;
+  display: inline-block;
+  overflow: visible !important;
+  vertical-align: text-bottom;
+  fill: currentColor;
+}
+
+.markdown-alert.markdown-alert-note {
+  border-left-color: var(--color-note);
+}
+
+.markdown-alert.markdown-alert-note .markdown-alert-title {
+  color: var(--color-note);
+}
+
+.markdown-alert.markdown-alert-important {
+  border-left-color: var(--color-important);
+}
+
+.markdown-alert.markdown-alert-important .markdown-alert-title {
+  color: var(--color-important);
+}
+
+.markdown-alert.markdown-alert-warning {
+  border-left-color: var(--color-warning);
+}
+
+.markdown-alert.markdown-alert-warning .markdown-alert-title {
+  color: var(--color-warning);
+}
+
+.markdown-alert.markdown-alert-tip {
+  border-left-color: var(--color-tip);
+}
+
+.markdown-alert.markdown-alert-tip .markdown-alert-title {
+  color: var(--color-tip);
+}
+
+.markdown-alert.markdown-alert-caution {
+  border-left-color: var(--color-caution);
+}
+
+.markdown-alert.markdown-alert-caution .markdown-alert-title {
+  color: var(--color-caution);
+}
+
+</style>
+        
+        </head>
+        <body class="vscode-body vscode-light">
+            <h1 id="modern-programming-practices---exam">Modern Programming Practices - Exam</h1>
+<table>
+<thead>
+<tr>
+<th>Metadata</th>
+<th>Value</th>
+</tr>
+</thead>
+<tbody>
+<tr>
+<td>Course code</td>
+<td>CU75045V1</td>
+</tr>
+<tr>
+<td>Lecturer</td>
+<td>Loek van der Linde</td>
+</tr>
+<tr>
+<td>Date</td>
+<td>27-10-2025</td>
+</tr>
+<tr>
+<td>Deadline</td>
+<td>02-11-2025 23:59</td>
+</tr>
+<tr>
+<td>Opportunity</td>
+<td>1st</td>
+</tr>
+</tbody>
+</table>
+<h2 id="do-this-first">Do this first</h2>
+<p>If you haven't already version controlled your code, do so <strong>now</strong>. Initialize a git repository and commit the current status. You have to hand in a git diff comparing your exam with your current code at the end of this exam. If you can't hand in a git diff from your current code, your exam will not be valid and will not be graded.</p>
+<p>You don't have to put your repository on GitHub. Just create a local repo and commit the current status.</p>
+<p>If you need help with initializing, committing and diffing then look at your exam from CIN where you had to do all of that.</p>
+<h2 id="assignment">Assignment</h2>
+<p>Read the grading criteria on the last page of this document. If your app can't possibly pass the <em>Architecture</em> criterion, you're allowed to rewrite it so that it does[^footnote1]. By now you've hopefully figured out there are only two sane architectural decisions: either a standard three-tier app, or Onion architecture (/Clean/Hegaxonal architecture).</p>
+<p>If you're choosing to rewrite, you can keep using CodeGrade to check whether your code still passes all the tests. When you're happy with your rewrite, make another commit and save the git diff comparing it against your first code. If you rewrite, you have to submit 2 git diffs! One of your first code comparing with your new code, and then another one comparing your exam implementation with your new code.</p>
+<p>[^footnote1]: Note that this goes for about half of you: I didn't teach you 11 lectures + had you do loads of reading on good programming just so you can write the equivalent of a 1000 line if-statement and expect to pass. Don't get me wrong, I'm not salty or angry. I just don't understand why I say it's an 80-100 hour assignment and your submission basically amounts to the Gilded Rose starter code pumped up on five barrels of steroids, mostly written by [insert your favorite chatbot]. I hope it was fun writing it at least..?</p>
+<p>When you're happy with your (new) code, your exam assignment is below.</p>
+<h3 id="exam---racial-skill-proficiencies">Exam - Racial skill proficiencies</h3>
+<p>Show racial skill proficiencies in your character sheets! The SRD lists quite a few, such as <code>Stonecunning</code> for a Dwarf, and <code>Keen senses</code> for Elf.</p>
+<p>You can ignore prerequisites and special modifiers and just handle them as regular proficiencies. According to the SRD a Dwarf could add double proficiency bonus on a History check when it's related to stone. But we're implementing a regular proficiency: in our app, <code>Stonecunning</code> means that a Dwarf is proficient in History.</p>
+<p>Below are two test cases:</p>
+<table>
+<thead>
+<tr>
+<th>Test case</th>
+<th>Skill proficiencies</th>
+</tr>
+</thead>
+<tbody>
+<tr>
+<td>Level 1 Dwarf Acolyte Rogue</td>
+<td>acrobatics, athletics, deception, insight, insight, history, religion</td>
+</tr>
+<tr>
+<td>Level 1 Half-Orc Acolyte Barbarian</td>
+<td>animal handling, athletics, insight, intimidation, religion</td>
+</tr>
+</tbody>
+</table>
+<h2 id="what-do-you-submit">What do you submit</h2>
+<ol>
+<li>A git diff of your exam code compared to the code that you started with before the exam;</li>
+<li>In case you opted to rewrite your starting code: a git diff comparing your first starting code with your new starting code;</li>
+<li>A .zip of your code;</li>
+<li>A short report containing explanation for the Maintainability and Testing criteria. Take as much or as little words/graphics as you need.</li>
+</ol>
+<h2 id="grading-criteria">Grading criteria</h2>
+<p>You can earn 100 points for the exam. Your grade is your amount of points divided by 10.</p>
+<p>There are four entry requirements for this exam:</p>
+<ol>
+<li>You have finished the CodeGrade assignment on 100%;</li>
+<li>You successfully implemented the requested feature;</li>
+<li>Your code compiles;</li>
+<li>You have submitted all the necessary things.</li>
+</ol>
+<p>When you don't meet these criteria, your submission will not be graded and you will not receive feedback.</p>
+<table>
+<thead>
+<tr>
+<th>Criterion</th>
+<th>Points</th>
+<th>0%</th>
+<th>50%</th>
+<th>100%</th>
+</tr>
+</thead>
+<tbody>
+<tr>
+<td>Architecture (measured through extensibility)</td>
+<td>60</td>
+<td>Responsiblities are all over the place. Implementing the feature forces cascading changes throughout the codebase, thereby violating the open/closed principle</td>
+<td>One or two functionalities exist in the wrong layer, but otherwise well-written. Implementing the feature forces cascading changes, but barely: in only one or two places, thereby almost adhering to the open/closed principle</td>
+<td>Good architecture where all functionalities exist in the right layers. Implementing the features does not force cascading changes, fully adhering to the open/closed principle</td>
+</tr>
+<tr>
+<td>Maintainability</td>
+<td>20</td>
+<td>No (good enough) effort has been put in explaining why the code is good</td>
+<td>Can explain why the code is good but does not show concrete proof, i.e. metrics, (graphic) models or other reputable sources</td>
+<td>Shows why the code is good with concrete proof</td>
+</tr>
+<tr>
+<td>Testing</td>
+<td>20</td>
+<td>No testing has been done</td>
+<td>Tests show the functionality passes the happy path</td>
+<td>Tests show a combination of manual and automated tests OR show that important edge cases have been handled</td>
+</tr>
+</tbody>
+</table>
+
+            
+            
+        </body>
+        </html>
\ No newline at end of file
diff --git a/dndcharactersheet b/dndcharactersheet
new file mode 100755
index 0000000..b522441
Binary files /dev/null and b/dndcharactersheet differ
diff --git a/internal/adapters/referencedata/json_repository.go b/internal/adapters/referencedata/json_repository.go
new file mode 100644
index 0000000..f70e410
--- /dev/null
+++ b/internal/adapters/referencedata/json_repository.go
@@ -0,0 +1,130 @@
+package referencedata
+
+import (
+	"encoding/json"
+	"fmt"
+	"os"
+	"strings"
+
+	backgroundModel "modules/dndcharactersheet/internal/domain/background"
+	classModel "modules/dndcharactersheet/internal/domain/class"
+	"modules/dndcharactersheet/internal/ports"
+)
+
+// JSONBackgroundRepository loads background data from a JSON file.
+type JSONBackgroundRepository struct {
+	filename string
+}
+
+// NewJSONBackgroundRepository creates a new background repository.
+func NewJSONBackgroundRepository(filename string) *JSONBackgroundRepository {
+	return &JSONBackgroundRepository{filename: filename}
+}
+
+// LoadBackgrounds loads all backgrounds from the JSON file.
+func (r *JSONBackgroundRepository) LoadBackgrounds() ([]backgroundModel.Background, error) {
+	data, err := os.ReadFile(r.filename)
+	if err != nil {
+		return nil, err
+	}
+
+	// Use a storage model with JSON tags for deserialization
+	var storageBackgrounds []struct {
+		Name               string   `json:"name"`
+		SkillProficiencies []string `json:"skill_proficiencies"`
+	}
+
+	if err := json.Unmarshal(data, &storageBackgrounds); err != nil {
+		return nil, err
+	}
+
+	// Convert to domain models
+	backgrounds := make([]backgroundModel.Background, len(storageBackgrounds))
+	for i, sb := range storageBackgrounds {
+		backgrounds[i] = backgroundModel.Background{
+			Name:               sb.Name,
+			SkillProficiencies: sb.SkillProficiencies,
+		}
+	}
+
+	return backgrounds, nil
+}
+
+// FindByName searches for a background by name (case-insensitive).
+func (r *JSONBackgroundRepository) FindByName(name string) (*backgroundModel.Background, error) {
+	backgrounds, err := r.LoadBackgrounds()
+	if err != nil {
+		return nil, err
+	}
+
+	for _, bg := range backgrounds {
+		if strings.EqualFold(bg.Name, name) {
+			return &bg, nil
+		}
+	}
+
+	return nil, fmt.Errorf("background not found: %s", name)
+}
+
+// Ensure JSONBackgroundRepository satisfies the interface.
+var _ ports.BackgroundRepository = (*JSONBackgroundRepository)(nil)
+
+// JSONClassRepository loads class data from a JSON file.
+type JSONClassRepository struct {
+	filename string
+}
+
+// NewJSONClassRepository creates a new class repository.
+func NewJSONClassRepository(filename string) *JSONClassRepository {
+	return &JSONClassRepository{filename: filename}
+}
+
+// LoadClasses loads all classes from the JSON file.
+func (r *JSONClassRepository) LoadClasses() ([]classModel.Class, error) {
+	data, err := os.ReadFile(r.filename)
+	if err != nil {
+		return nil, err
+	}
+
+	// Use a storage model with JSON tags for deserialization
+	var storageClasses []struct {
+		Name               string   `json:"name"`
+		SkillProficiencies []string `json:"skill_proficiencies"`
+		SkillCount         int      `json:"skill_count"`
+	}
+
+	if err := json.Unmarshal(data, &storageClasses); err != nil {
+		return nil, err
+	}
+
+	// Convert to domain models
+	classes := make([]classModel.Class, len(storageClasses))
+	for i, sc := range storageClasses {
+		classes[i] = classModel.Class{
+			Name:               sc.Name,
+			SkillProficiencies: sc.SkillProficiencies,
+			SkillCount:         sc.SkillCount,
+		}
+	}
+
+	return classes, nil
+}
+
+// FindByName searches for a class by name (case-insensitive).
+func (r *JSONClassRepository) FindByName(name string) (*classModel.Class, error) {
+	classes, err := r.LoadClasses()
+	if err != nil {
+		return nil, err
+	}
+
+	for _, cls := range classes {
+		if strings.EqualFold(cls.Name, name) {
+			return &cls, nil
+		}
+	}
+
+	return nil, fmt.Errorf("class not found: %s", name)
+}
+
+// Ensure JSONClassRepository satisfies the interface.
+var _ ports.ClassRepository = (*JSONClassRepository)(nil)
diff --git a/internal/adapters/spellcasting/engine_adapter.go b/internal/adapters/spellcasting/engine_adapter.go
index ac7aec9..bd8286c 100644
--- a/internal/adapters/spellcasting/engine_adapter.go
+++ b/internal/adapters/spellcasting/engine_adapter.go
@@ -1,77 +1,173 @@
 package spellcastingadapter
 
 import (
+	"fmt"
 	"strings"
 
+	"modules/dndcharactersheet/internal/domain/spellcasting"
 	"modules/dndcharactersheet/internal/ports"
-	legacy "modules/dndcharactersheet/internal/spellcasting"
 )
 
-// EngineAdapter wraps the legacy spellcasting helpers behind the SpellcastingEngine port.
-type EngineAdapter struct{}
+// EngineAdapter implements the SpellcastingEngine port using domain spellcasting logic.
+type EngineAdapter struct {
+	spellRepo ports.SpellRepository
+}
 
-func NewEngineAdapter() *EngineAdapter { return &EngineAdapter{} }
+// NewEngineAdapter creates a new spellcasting engine adapter.
+func NewEngineAdapter(spellRepo ports.SpellRepository) *EngineAdapter {
+	return &EngineAdapter{
+		spellRepo: spellRepo,
+	}
+}
 
 func (e *EngineAdapter) AssignSpellcasting(class string, level int) (interface{}, error) {
-	sc := legacy.AssignSpellcasting(class, level)
+	sc := spellcasting.NewSpellcasting(class, level)
 	return sc, nil
 }
 
 func (e *EngineAdapter) LearnSpell(sc interface{}, class string, spellName string) (interface{}, string, error) {
-	spells, err := legacy.LoadSpells("5e-SRD-Spells.csv")
+	scTyped, ok := sc.(*spellcasting.Spellcasting)
+	if !ok {
+		return sc, "invalid spellcasting data", nil
+	}
+
+	// Check caster type
+	if scTyped.CasterType != spellcasting.CasterKnown && scTyped.CasterType != spellcasting.CasterPact {
+		return sc, "this class prepares spells and can't learn them", nil
+	}
+
+	// Load spells to validate the spell exists and is available to the class
+	spells, err := e.spellRepo.LoadSpells()
 	if err != nil {
 		return sc, "", err
 	}
-	var found *legacy.Spell
+
+	classSpells := e.spellRepo.FilterByClass(spells, class)
+
 	lname := strings.ToLower(spellName)
-	lclass := strings.ToLower(class)
-	for _, s := range spells {
-		if strings.EqualFold(s.Name, lname) && strings.Contains(strings.ToLower(s.Class), lclass) {
-			found = &s
+	found := false
+	for _, s := range classSpells {
+		if strings.EqualFold(s.Name, lname) {
+			found = true
 			break
 		}
 	}
-	// If not found, still try to learn to surface legacy validation message
-	scTyped, _ := sc.(legacy.CharacterSpellcasting)
-	if found == nil {
-		msg := legacy.LearnSpell(&scTyped, legacy.Spell{Name: spellName})
-		return scTyped, msg, nil
+
+	if !found {
+		return sc, fmt.Sprintf("spell '%s' not found or not available to %s", spellName, class), nil
 	}
-	msg := legacy.LearnSpell(&scTyped, *found)
-	return scTyped, msg, nil
+
+	// Use domain method to learn the spell
+	if !scTyped.LearnSpell(spellName) {
+		return sc, "already learned this spell", nil
+	}
+
+	return scTyped, fmt.Sprintf("learned spell %s", strings.ToLower(spellName)), nil
 }
 
 func (e *EngineAdapter) PrepareSpell(sc interface{}, class string, spellName string) (interface{}, string, error) {
-	spells, err := legacy.LoadSpells("5e-SRD-Spells.csv")
+	scTyped, ok := sc.(*spellcasting.Spellcasting)
+	if !ok {
+		return sc, "invalid spellcasting data", nil
+	}
+
+	// Check caster type
+	if scTyped.CasterType != spellcasting.CasterFull && scTyped.CasterType != spellcasting.CasterHalf {
+		return sc, "this class learns spells and can't prepare them", nil
+	}
+
+	// Load spells to get level information
+	spells, err := e.spellRepo.LoadSpells()
 	if err != nil {
 		return sc, "", err
 	}
-	var found *legacy.Spell
+
+	classSpells := e.spellRepo.FilterByClass(spells, class)
+
 	lname := strings.ToLower(spellName)
-	lclass := strings.ToLower(class)
-	for _, s := range spells {
-		if strings.EqualFold(s.Name, lname) && strings.Contains(strings.ToLower(s.Class), lclass) {
-			found = &s
+	var foundSpell *ports.Spell
+	for _, s := range classSpells {
+		if strings.EqualFold(s.Name, lname) {
+			foundSpell = &s
 			break
 		}
 	}
-	scTyped, _ := sc.(legacy.CharacterSpellcasting)
-	if found == nil {
-		msg := legacy.PrepareSpell(&scTyped, legacy.Spell{Name: spellName})
-		return scTyped, msg, nil
+
+	if foundSpell == nil {
+		return sc, fmt.Sprintf("spell '%s' not found or not available to %s", spellName, class), nil
 	}
-	msg := legacy.PrepareSpell(&scTyped, *found)
-	return scTyped, msg, nil
+
+	// Check spell level against available slots (unless it's a cantrip)
+	if foundSpell.Level > 0 {
+		maxSlot := 0
+		for lvl := range scTyped.SpellSlots {
+			if lvl > maxSlot {
+				maxSlot = lvl
+			}
+		}
+		if foundSpell.Level > maxSlot {
+			return sc, "the spell has higher level than the available spell slots", nil
+		}
+	}
+
+	// Use domain method to prepare the spell
+	if err := scTyped.PrepareSpell(spellName); err != nil {
+		return sc, err.Error(), nil
+	}
+
+	return scTyped, fmt.Sprintf("prepared spell %s", strings.ToLower(spellName)), nil
 }
 
 func (e *EngineAdapter) FormatSpellSlots(sc interface{}, class string, level int) string {
-	scTyped, _ := sc.(legacy.CharacterSpellcasting)
-	return legacy.FormatSpellSlots(&scTyped, class, level)
+	scTyped, ok := sc.(*spellcasting.Spellcasting)
+	if !ok {
+		return ""
+	}
+
+	var sb strings.Builder
+	sb.WriteString("Spell slots:\n")
+
+	// Print cantrips as Level 0 using domain function
+	cantrips := spellcasting.GetCantripsKnown(class, level)
+	if cantrips > 0 {
+		sb.WriteString(fmt.Sprintf("  Level 0: %d\n", cantrips))
+	}
+
+	// Print actual spell slots (levels 1-9)
+	if scTyped.SpellSlots != nil {
+		for lvl := 1; lvl <= 9; lvl++ {
+			if slots, exists := scTyped.SpellSlots[lvl]; exists {
+				sb.WriteString(fmt.Sprintf("  Level %d: %d\n", lvl, slots))
+			}
+		}
+	}
+	return sb.String()
 }
 
 func (e *EngineAdapter) FormatCantrips(sc interface{}) string {
-	scTyped, _ := sc.(legacy.CharacterSpellcasting)
-	return legacy.FormatCantrips(&scTyped)
+	scTyped, ok := sc.(*spellcasting.Spellcasting)
+	if !ok {
+		return ""
+	}
+
+	// If cantrips are tracked in SpellSlots (level 0)
+	if slots, exists := scTyped.SpellSlots[0]; exists {
+		return fmt.Sprintf("Spell slots:\n  Level 0: %d\n", slots)
+	}
+
+	// If cantrips are tracked in KnownSpells
+	if len(scTyped.KnownSpells) > 0 {
+		var cantrips []string
+		for _, spellName := range scTyped.KnownSpells {
+			if strings.Contains(strings.ToLower(spellName), "cantrip") || strings.Contains(strings.ToLower(spellName), "level 0") {
+				cantrips = append(cantrips, spellName)
+			}
+		}
+		if len(cantrips) > 0 {
+			return fmt.Sprintf("Cantrips: %s\n", strings.Join(cantrips, ", "))
+		}
+	}
+	return ""
 }
 
 var _ ports.SpellcastingEngine = (*EngineAdapter)(nil)
diff --git a/internal/adapters/spellcasting/spell_repository.go b/internal/adapters/spellcasting/spell_repository.go
new file mode 100644
index 0000000..51e6f1a
--- /dev/null
+++ b/internal/adapters/spellcasting/spell_repository.go
@@ -0,0 +1,93 @@
+package spellcastingadapter
+
+import (
+	"encoding/csv"
+	"modules/dndcharactersheet/internal/ports"
+	"os"
+	"strconv"
+	"strings"
+)
+
+// CSVSpellRepository implements the SpellRepository port using CSV files.
+type CSVSpellRepository struct {
+	filename string
+}
+
+// NewCSVSpellRepository creates a new CSV-based spell repository.
+func NewCSVSpellRepository(filename string) *CSVSpellRepository {
+	return &CSVSpellRepository{
+		filename: filename,
+	}
+}
+
+// LoadSpells loads spells from the CSV file.
+func (r *CSVSpellRepository) LoadSpells() ([]ports.Spell, error) {
+	file, err := os.Open(r.filename)
+	if err != nil {
+		return nil, err
+	}
+	defer file.Close()
+
+	reader := csv.NewReader(file)
+	records, err := reader.ReadAll()
+	if err != nil {
+		return nil, err
+	}
+
+	var spells []ports.Spell
+	for i, rec := range records {
+		if i == 0 {
+			continue // skip header
+		}
+
+		// CSV format: Name, Level, Class/Classes, ...
+		level, _ := strconv.Atoi(rec[1])
+		classes := parseClasses(rec[2])
+
+		spells = append(spells, ports.Spell{
+			Index:   toIndex(rec[0]),
+			Name:    rec[0],
+			Level:   level,
+			Classes: classes,
+		})
+	}
+	return spells, nil
+}
+
+// FilterByClass filters spells available to a specific class.
+func (r *CSVSpellRepository) FilterByClass(spells []ports.Spell, class string) []ports.Spell {
+	var filtered []ports.Spell
+	class = strings.ToLower(class)
+
+	for _, s := range spells {
+		for _, c := range s.Classes {
+			if strings.EqualFold(c, class) {
+				filtered = append(filtered, s)
+				break
+			}
+		}
+	}
+	return filtered
+}
+
+// parseClasses splits a comma-separated list of classes.
+func parseClasses(classStr string) []string {
+	if classStr == "" {
+		return []string{}
+	}
+
+	parts := strings.Split(classStr, ",")
+	classes := make([]string, 0, len(parts))
+	for _, p := range parts {
+		trimmed := strings.TrimSpace(p)
+		if trimmed != "" {
+			classes = append(classes, trimmed)
+		}
+	}
+	return classes
+}
+
+// toIndex converts a spell name to an index format.
+func toIndex(name string) string {
+	return strings.ToLower(strings.ReplaceAll(name, " ", "-"))
+}
diff --git a/internal/storage/model.go b/internal/adapters/storage/jsonstorage/model.go
similarity index 100%
rename from internal/storage/model.go
rename to internal/adapters/storage/jsonstorage/model.go
diff --git a/internal/storage/single_file_storage.go b/internal/adapters/storage/jsonstorage/single_file_storage.go
similarity index 100%
rename from internal/storage/single_file_storage.go
rename to internal/adapters/storage/jsonstorage/single_file_storage.go
diff --git a/internal/adapters/storage/repository.go b/internal/adapters/storage/repository.go
index 5e3a84c..b9e809e 100644
--- a/internal/adapters/storage/repository.go
+++ b/internal/adapters/storage/repository.go
@@ -1,11 +1,13 @@
 package storage
 
 import (
+	"encoding/json"
 	"fmt"
 
+	stor "modules/dndcharactersheet/internal/adapters/storage/jsonstorage"
 	characterpkg "modules/dndcharactersheet/internal/domain/character"
+	"modules/dndcharactersheet/internal/domain/spellcasting"
 	"modules/dndcharactersheet/internal/ports"
-	stor "modules/dndcharactersheet/internal/storage"
 )
 
 // JSONRepository implements ports.CharacterRepository by delegating to the existing
@@ -85,7 +87,7 @@ func domainToStorage(d *characterpkg.Character) stor.Character {
 		OffHand:            d.OffHand,
 		Armor:              d.Armor,
 		Shield:             d.Shield,
-		Spellcasting:       d.Spellcasting,
+		Spellcasting:       marshalSpellcasting(d.Spellcasting),
 		StrMod:             d.StrMod,
 		DexMod:             d.DexMod,
 		ConMod:             d.ConMod,
@@ -119,7 +121,7 @@ func storageToDomain(s *stor.Character) *characterpkg.Character {
 		OffHand:            s.OffHand,
 		Armor:              s.Armor,
 		Shield:             s.Shield,
-		Spellcasting:       s.Spellcasting,
+		Spellcasting:       unmarshalSpellcasting(s.Spellcasting),
 		StrMod:             s.StrMod,
 		DexMod:             s.DexMod,
 		ConMod:             s.ConMod,
@@ -133,3 +135,66 @@ func storageToDomain(s *stor.Character) *characterpkg.Character {
 	}
 	return d
 }
+
+// marshalSpellcasting converts domain spellcasting to storage format (with JSON-serializable structure).
+func marshalSpellcasting(data interface{}) interface{} {
+	if data == nil {
+		return nil
+	}
+
+	// Type assert to domain spellcasting
+	sc, ok := data.(*spellcasting.Spellcasting)
+	if !ok {
+		return data // Return as-is if not our type
+	}
+
+	// Create a storage model with JSON tags for serialization
+	storageModel := struct {
+		CasterType     string      `json:"CasterType"`
+		KnownSpells    []string    `json:"KnownSpells"`
+		PreparedSpells []string    `json:"PreparedSpells"`
+		SpellSlots     map[int]int `json:"SpellSlots"`
+	}{
+		CasterType:     string(sc.CasterType),
+		KnownSpells:    sc.KnownSpells,
+		PreparedSpells: sc.PreparedSpells,
+		SpellSlots:     sc.SpellSlots,
+	}
+
+	return storageModel
+}
+
+// unmarshalSpellcasting converts the storage interface{} back to domain spellcasting type.
+func unmarshalSpellcasting(data interface{}) interface{} {
+	if data == nil {
+		return nil
+	}
+
+	// When loading from JSON, interface{} will be a map[string]interface{}
+	// Use a storage model with JSON tags for deserialization
+	jsonBytes, err := json.Marshal(data)
+	if err != nil {
+		return nil
+	}
+
+	var storageModel struct {
+		CasterType     string      `json:"CasterType"`
+		KnownSpells    []string    `json:"KnownSpells"`
+		PreparedSpells []string    `json:"PreparedSpells"`
+		SpellSlots     map[int]int `json:"SpellSlots"`
+	}
+
+	if err := json.Unmarshal(jsonBytes, &storageModel); err != nil {
+		return nil
+	}
+
+	// Map to domain model (no JSON tags)
+	sc := &spellcasting.Spellcasting{
+		CasterType:     spellcasting.CasterType(storageModel.CasterType),
+		KnownSpells:    storageModel.KnownSpells,
+		PreparedSpells: storageModel.PreparedSpells,
+		SpellSlots:     storageModel.SpellSlots,
+	}
+
+	return sc
+}
diff --git a/internal/adapters/storage/repository_spellcasting_test.go b/internal/adapters/storage/repository_spellcasting_test.go
new file mode 100644
index 0000000..db633f5
--- /dev/null
+++ b/internal/adapters/storage/repository_spellcasting_test.go
@@ -0,0 +1,74 @@
+package storage
+
+import (
+    "os"
+    "path/filepath"
+    "testing"
+
+    characterpkg "modules/dndcharactersheet/internal/domain/character"
+    spkg "modules/dndcharactersheet/internal/domain/spellcasting"
+)
+
+func TestRepository_SpellcastingRoundTrip(t *testing.T) {
+    dir := t.TempDir()
+    file := filepath.Join(dir, "characters.json")
+
+    repo := NewJSONRepository(file)
+
+    // Create a character with spellcasting
+    sc := spkg.NewSpellcasting("wizard", 3)
+    sc.LearnSpell("magic missile")
+    if err := sc.PrepareSpell("magic missile"); err != nil {
+        t.Fatalf("prepare should succeed after learning: %v", err)
+    }
+
+    ch := &characterpkg.Character{
+        Name:        "RepoSpellTest",
+        Race:        "human",
+        Class:       "wizard",
+        Level:       3,
+        Str:         10,
+        Dex:         12,
+        Con:         12,
+        Int:         14,
+        Wis:         10,
+        Cha:         8,
+        Spellcasting: sc,
+    }
+
+    if err := repo.Save(ch); err != nil {
+        t.Fatalf("save failed: %v", err)
+    }
+
+    // Ensure file written
+    if _, err := os.Stat(file); err != nil {
+        t.Fatalf("expected file to exist: %v", err)
+    }
+
+    // Load back
+    got, err := repo.GetByID("RepoSpellTest")
+    if err != nil {
+        t.Fatalf("get failed: %v", err)
+    }
+    if got.Spellcasting == nil {
+        t.Fatalf("expected spellcasting to be non-nil after load")
+    }
+
+    // Type assertion to domain type
+    sc2, ok := got.Spellcasting.(*spkg.Spellcasting)
+    if !ok {
+        t.Fatalf("expected spellcasting to be *spellcasting.Spellcasting, got %T", got.Spellcasting)
+    }
+
+    if len(sc2.KnownSpells) != 1 || sc2.KnownSpells[0] != "magic missile" {
+        t.Fatalf("known spells after load mismatch: %#v", sc2.KnownSpells)
+    }
+    if len(sc2.PreparedSpells) != 1 || sc2.PreparedSpells[0] != "magic missile" {
+        t.Fatalf("prepared spells after load mismatch: %#v", sc2.PreparedSpells)
+    }
+
+    // Check some slots present
+    if len(sc2.SpellSlots) == 0 {
+        t.Fatalf("expected spell slots to be present after load")
+    }
+}
diff --git a/internal/api/client.go b/internal/api/client.go
deleted file mode 100644
index 3299d73..0000000
--- a/internal/api/client.go
+++ /dev/null
@@ -1,227 +0,0 @@
-package api
-
-import (
-	"encoding/json"
-	"fmt"
-	"net/http"
-	"strings"
-)
-
-const BaseURL = "https://www.dnd5eapi.co/api/2014"
-
-// Local API from Docker image
-//const BaseURL = "http://localhost:3000/api/2014"
-
-// ToAPIIndex converts a spell or item name to the API index format (kebab-case)
-func ToAPIIndex(name string) string {
-	return strings.ToLower(strings.ReplaceAll(strings.TrimSpace(name), " ", "-"))
-}
-
-// WeaponEnriched holds extra weapon info from the API
-type WeaponEnriched struct {
-	Name     string `json:"name"`
-	Category string `json:"weapon_category"`
-	Range    struct {
-		Normal int `json:"normal"`
-	} `json:"range"`
-	TwoHanded bool `json:"two_handed"`
-}
-
-// ArmorEnriched holds extra armor info from the API
-type ArmorEnriched struct {
-	Name       string `json:"name"`
-	ArmorClass struct {
-		Base     int  `json:"base"`
-		DexBonus bool `json:"dex_bonus"`
-	} `json:"armor_class"`
-}
-
-// GetWeapon fetches and decodes weapon details by index (e.g., "longsword")
-func GetWeapon(index string) (*WeaponEnriched, error) {
-	url := fmt.Sprintf("%s/equipment/%s", BaseURL, index)
-	resp, err := http.Get(url)
-	if err != nil {
-		return nil, err
-	}
-	defer resp.Body.Close()
-
-	if resp.StatusCode != http.StatusOK {
-		return nil, fmt.Errorf("API returned status: %s", resp.Status)
-	}
-
-	var weapon WeaponEnriched
-	if err := json.NewDecoder(resp.Body).Decode(&weapon); err != nil {
-		return nil, err
-	}
-	return &weapon, nil
-}
-
-// GetArmor fetches and decodes armor details by index (e.g., "chain-mail")
-func GetArmor(index string) (*ArmorEnriched, error) {
-	url := fmt.Sprintf("%s/equipment/%s", BaseURL, index)
-	resp, err := http.Get(url)
-	if err != nil {
-		return nil, err
-	}
-	defer resp.Body.Close()
-
-	if resp.StatusCode != http.StatusOK {
-		return nil, fmt.Errorf("API returned status: %s", resp.Status)
-	}
-
-	var armor ArmorEnriched
-	if err := json.NewDecoder(resp.Body).Decode(&armor); err != nil {
-		return nil, err
-	}
-	return &armor, nil
-}
-
-// FetchWeaponsWithWorkers fetches weapon details for a list of indexes using a worker pool
-func FetchWeaponsWithWorkers(indexes []string, workerCount int) []*WeaponEnriched {
-	type job struct {
-		i   int
-		idx string
-	}
-	type result struct {
-		i      int
-		weapon *WeaponEnriched
-		err    error
-	}
-
-	jobs := make(chan job, len(indexes))
-	results := make(chan result, len(indexes))
-
-	for w := 0; w < workerCount; w++ {
-		go func() {
-			for j := range jobs {
-				weapon, err := GetWeapon(j.idx)
-				results <- result{j.i, weapon, err}
-			}
-		}()
-	}
-
-	for i, idx := range indexes {
-		jobs <- job{i, idx}
-	}
-	close(jobs)
-
-	out := make([]*WeaponEnriched, len(indexes))
-	for i := 0; i < len(indexes); i++ {
-		res := <-results
-		out[res.i] = res.weapon
-		if res.err != nil {
-			fmt.Printf("Failed to fetch weapon %s: %v\n", indexes[res.i], res.err)
-		}
-	}
-	return out
-}
-
-// FetchArmorsWithWorkers fetches armor details for a list of indexes using a worker pool
-func FetchArmorsWithWorkers(indexes []string, workerCount int) []*ArmorEnriched {
-	type job struct {
-		i   int
-		idx string
-	}
-	type result struct {
-		i     int
-		armor *ArmorEnriched
-		err   error
-	}
-
-	jobs := make(chan job, len(indexes))
-	results := make(chan result, len(indexes))
-
-	for w := 0; w < workerCount; w++ {
-		go func() {
-			for j := range jobs {
-				armor, err := GetArmor(j.idx)
-				results <- result{j.i, armor, err}
-			}
-		}()
-	}
-
-	for i, idx := range indexes {
-		jobs <- job{i, idx}
-	}
-	close(jobs)
-
-	out := make([]*ArmorEnriched, len(indexes))
-	for i := 0; i < len(indexes); i++ {
-		res := <-results
-		out[res.i] = res.armor
-		if res.err != nil {
-			fmt.Printf("Failed to fetch armor %s: %v\n", indexes[res.i], res.err)
-		}
-	}
-	return out
-}
-
-// SpellEnriched holds extra spell info from the API
-type SpellEnriched struct {
-	Name   string `json:"name"`
-	Range  string `json:"range"`
-	School struct {
-		Name string `json:"name"`
-	} `json:"school"`
-}
-
-// GetSpell fetches and decodes spell details by index (e.g., "acid-arrow")
-func GetSpell(index string) (*SpellEnriched, error) {
-	url := fmt.Sprintf("%s/spells/%s", BaseURL, index)
-	resp, err := http.Get(url)
-	if err != nil {
-		return nil, err
-	}
-	defer resp.Body.Close()
-
-	if resp.StatusCode != http.StatusOK {
-		return nil, fmt.Errorf("API returned status: %s", resp.Status)
-	}
-
-	var spell SpellEnriched
-	if err := json.NewDecoder(resp.Body).Decode(&spell); err != nil {
-		return nil, err
-	}
-	return &spell, nil
-}
-
-// Fetches spell details for a list of indexes using a worker pool
-func FetchSpellsWithWorkers(names []string, workerCount int) []*SpellEnriched {
-	type job struct {
-		i    int
-		name string
-	}
-	type result struct {
-		i     int
-		spell *SpellEnriched
-		err   error
-	}
-
-	jobs := make(chan job, len(names))
-	results := make(chan result, len(names))
-
-	for w := 0; w < workerCount; w++ {
-		go func() {
-			for j := range jobs {
-				idx := ToAPIIndex(j.name)
-				spell, err := GetSpell(idx)
-				results <- result{j.i, spell, err}
-			}
-		}()
-	}
-
-	for i, name := range names {
-		jobs <- job{i, name}
-	}
-	close(jobs)
-
-	out := make([]*SpellEnriched, len(names))
-	for i := 0; i < len(names); i++ {
-		res := <-results
-		out[res.i] = res.spell
-		if res.err != nil {
-			fmt.Printf("Failed to fetch spell %s: %v\n", names[res.i], res.err)
-		}
-	}
-	return out
-}
diff --git a/internal/api/client_test.go b/internal/api/client_test.go
deleted file mode 100644
index 4ab8c2c..0000000
--- a/internal/api/client_test.go
+++ /dev/null
@@ -1,42 +0,0 @@
-package api
-
-import (
-	"fmt"
-	"testing"
-)
-
-func TestFetchSpellsWithWorkers(t *testing.T) {
-	indexes := []string{"acid-arrow", "fireball", "mage-armor"}
-	results := FetchSpellsWithWorkers(indexes, 3)
-	for i, s := range results {
-		if s == nil {
-			t.Errorf("Spell %s not enriched", indexes[i])
-		} else {
-			fmt.Printf("Spell: %+v\n", s)
-		}
-	}
-}
-
-func TestFetchWeaponsWithWorkers(t *testing.T) {
-	indexes := []string{"longsword", "shortbow"}
-	results := FetchWeaponsWithWorkers(indexes, 2)
-	for i, w := range results {
-		if w == nil {
-			t.Errorf("Weapon %s not enriched", indexes[i])
-		} else {
-			fmt.Printf("Weapon: %+v\n", w)
-		}
-	}
-}
-
-func TestFetchArmorsWithWorkers(t *testing.T) {
-	indexes := []string{"chain-mail", "leather-armor"}
-	results := FetchArmorsWithWorkers(indexes, 2)
-	for i, a := range results {
-		if a == nil {
-			t.Errorf("Armor %s not enriched", indexes[i])
-		} else {
-			fmt.Printf("Armor: %+v\n", a)
-		}
-	}
-}
diff --git a/internal/application/character_builder.go b/internal/application/character_builder.go
index a55244c..a26dfa7 100644
--- a/internal/application/character_builder.go
+++ b/internal/application/character_builder.go
@@ -4,8 +4,8 @@ import (
 	"sort"
 	"strings"
 
-	backgroundModel "modules/dndcharactersheet/internal/background"
-	classModel "modules/dndcharactersheet/internal/class"
+	backgroundModel "modules/dndcharactersheet/internal/domain/background"
+	classModel "modules/dndcharactersheet/internal/domain/class"
 )
 
 // CharacterBuilder provides helper functions for building characters.
diff --git a/internal/application/character_service.go b/internal/application/character_service.go
index 32c724d..cbe2067 100644
--- a/internal/application/character_service.go
+++ b/internal/application/character_service.go
@@ -71,6 +71,12 @@ func (s *CharacterService) RecalculateDerived(c *characterpkg.Character) {
 	}
 	c.PassivePerception = passive
 
+	// Spell Attack Bonus: Proficiency + Spellcasting Ability Modifier (if caster)
+	if c.Spellcasting != nil {
+		spellMod := s.getSpellcastingModifier(c)
+		c.SpellAttackBonus = c.Proficiency + spellMod
+	}
+
 	// Armor Class calculation
 	if s.armorEnricher == nil {
 		// Fallback minimal rule: base 10 + Dex mod (+2 if shield)
@@ -243,3 +249,42 @@ func (s *CharacterService) PrepareSpell(characterName, spellName string) error {
 	char.Spellcasting = updated
 	return s.repo.Save(char)
 }
+
+// getSpellcastingModifier returns the ability modifier for spellcasting based on class.
+func (s *CharacterService) getSpellcastingModifier(c *characterpkg.Character) int {
+	class := strings.ToLower(strings.TrimSpace(c.Class))
+	switch class {
+	case "wizard", "artificer":
+		return c.IntMod
+	case "cleric", "druid", "ranger":
+		return c.WisMod
+	case "bard", "sorcerer", "warlock", "paladin":
+		return c.ChaMod
+	default:
+		return c.IntMod // Default to INT
+	}
+}
+
+// GetSpellcastingAbilityName returns the name of the spellcasting ability for display.
+func (s *CharacterService) GetSpellcastingAbilityName(class string) string {
+	class = strings.ToLower(strings.TrimSpace(class))
+	switch class {
+	case "wizard", "artificer":
+		return "intelligence"
+	case "cleric", "druid", "ranger":
+		return "wisdom"
+	case "bard", "sorcerer", "warlock", "paladin":
+		return "charisma"
+	default:
+		return "intelligence"
+	}
+}
+
+// CalculateSpellSaveDC returns spell save DC: 8 + proficiency + spellcasting modifier.
+func (s *CharacterService) CalculateSpellSaveDC(c *characterpkg.Character) int {
+	if c.Spellcasting == nil {
+		return 0
+	}
+	spellMod := s.getSpellcastingModifier(c)
+	return 8 + c.Proficiency + spellMod
+}
diff --git a/internal/background/model.go b/internal/background/model.go
deleted file mode 100644
index c36c0d7..0000000
--- a/internal/background/model.go
+++ /dev/null
@@ -1,21 +0,0 @@
-package backgroundModel
-
-import (
-	"encoding/json"
-	"os"
-)
-
-type Background struct {
-	Name               string   `json:"name"`
-	SkillProficiencies []string `json:"skill_proficiencies"`
-}
-
-func LoadBackgrounds(filename string) ([]Background, error) {
-	data, err := os.ReadFile(filename)
-	if err != nil {
-		return nil, err
-	}
-	var backgrounds []Background
-	err = json.Unmarshal(data, &backgrounds)
-	return backgrounds, err
-}
diff --git a/internal/character/model.go b/internal/character/model.go
deleted file mode 100644
index f543555..0000000
--- a/internal/character/model.go
+++ /dev/null
@@ -1,35 +0,0 @@
-package characterModel
-
-type Character struct {
-	Name               string   `json:"name"`
-	Race               string   `json:"race"`
-	Class              string   `json:"class"`
-	Level              int      `json:"level"`
-	Str                int      `json:"str"`
-	Dex                int      `json:"dex"`
-	Con                int      `json:"con"`
-	Int                int      `json:"int"`
-	Wis                int      `json:"wis"`
-	Cha                int      `json:"cha"`
-	Background         string   `json:"background"`
-	Proficiency        int      `json:"proficiency"`
-	SkillProficiencies []string `json:"skill_proficiencies"`
-}
-
-// Returns the proficiency bonus based on character level
-func GetProficiencyBonus(level int) int {
-	switch {
-	case level >= 1 && level <= 4:
-		return 2
-	case level >= 5 && level <= 8:
-		return 3
-	case level >= 9 && level <= 12:
-		return 4
-	case level >= 13 && level <= 16:
-		return 5
-	case level >= 17:
-		return 6
-	default:
-		return 0
-	}
-}
diff --git a/internal/character/service.go b/internal/character/service.go
deleted file mode 100644
index 77f2639..0000000
--- a/internal/character/service.go
+++ /dev/null
@@ -1,118 +0,0 @@
-package characterModel
-
-import (
-	backgroundModel "modules/dndcharactersheet/internal/background"
-	classModel "modules/dndcharactersheet/internal/class"
-	"sort"
-	"strings"
-)
-
-type CharacterService struct{}
-
-func NewCharacterService() *CharacterService {
-	return &CharacterService{}
-}
-func (cs *CharacterService) GetProficiencyBonus(level int) int {
-	switch {
-	case level >= 1 && level <= 4:
-		return 2
-	case level >= 5 && level <= 8:
-		return 3
-	case level >= 9 && level <= 12:
-		return 4
-	case level >= 13 && level <= 16:
-		return 5
-	case level >= 17:
-		return 6
-	default:
-		return 0
-	}
-}
-
-func (cs *CharacterService) AbilityModifier(score int) int {
-	result := (score - 10) / 2
-	if (score-10)%2 < 0 {
-		result--
-	}
-	return result
-}
-
-func (cs *CharacterService) ApplyRacialBonuses(character *Character) {
-	switch strings.ToLower(character.Race) {
-	case "dwarf":
-		character.Con += 2
-	case "hill dwarf":
-		character.Con += 2
-		character.Wis += 1
-	case "elf":
-		character.Dex += 2
-	case "high elf":
-		character.Dex += 2
-		character.Int += 1
-	case "halfling":
-		character.Dex += 2
-	case "lightfoot halfling", "lightfoot":
-		character.Dex += 2
-		character.Cha += 1
-	case "human":
-		character.Str += 1
-		character.Dex += 1
-		character.Con += 1
-		character.Int += 1
-		character.Wis += 1
-		character.Cha += 1
-	case "dragonborn":
-		character.Str += 2
-		character.Cha += 1
-	case "gnome":
-		character.Int += 2
-	case "rock gnome":
-		character.Int += 2
-		character.Con += 1
-	case "half-elf":
-		character.Cha += 2
-		character.Dex += 1
-		character.Con += 1
-	case "half orc":
-		character.Str += 2
-		character.Con += 1
-	case "tiefling":
-		character.Int += 1
-		character.Cha += 2
-	}
-}
-
-func (cs *CharacterService) CombineSkillProficiencies(background backgroundModel.Background, class classModel.Class, userSkills []string) []string {
-	var combined []string
-
-	// Add class skills first (up to the class skill count)
-	classSkillsAdded := 0
-	for _, skill := range class.SkillProficiencies {
-		skill = strings.ToLower(strings.TrimSpace(skill))
-		if skill != "" && classSkillsAdded < class.SkillCount {
-			combined = append(combined, skill)
-			classSkillsAdded++
-		}
-	}
-
-	// Add user-selected skills
-	for _, skill := range userSkills {
-		skill = strings.ToLower(strings.TrimSpace(skill))
-		if skill != "" {
-			combined = append(combined, skill)
-		}
-	}
-
-	// Add background skills (allow duplicates)
-	for _, skill := range background.SkillProficiencies {
-		skill = strings.ToLower(strings.TrimSpace(skill))
-		if skill != "" {
-			combined = append(combined, skill)
-		}
-	}
-
-	// Sort alphabetically
-	sort.Strings(combined)
-
-	return combined
-}
diff --git a/internal/class/model.go b/internal/class/model.go
deleted file mode 100644
index 8f5e703..0000000
--- a/internal/class/model.go
+++ /dev/null
@@ -1,22 +0,0 @@
-package classModel
-
-import (
-	"encoding/json"
-	"os"
-)
-
-type Class struct {
-	Name               string   `json:"name"`
-	SkillProficiencies []string `json:"skill_proficiencies"`
-	SkillCount         int      `json:"skill_count"` // How many skills they can choose
-}
-
-func LoadClasses(filename string) ([]Class, error) {
-	data, err := os.ReadFile(filename)
-	if err != nil {
-		return nil, err
-	}
-	var classes []Class
-	err = json.Unmarshal(data, &classes)
-	return classes, err
-}
diff --git a/internal/domain/background/model.go b/internal/domain/background/model.go
new file mode 100644
index 0000000..3ffd510
--- /dev/null
+++ b/internal/domain/background/model.go
@@ -0,0 +1,8 @@
+package backgroundModel
+
+// Background represents character background reference data.
+// This is a pure domain value object with no infrastructure dependencies.
+type Background struct {
+	Name               string
+	SkillProficiencies []string
+}
diff --git a/internal/domain/character/character.go b/internal/domain/character/character.go
index ec87fa0..77a531f 100644
--- a/internal/domain/character/character.go
+++ b/internal/domain/character/character.go
@@ -5,35 +5,35 @@ import "strings"
 // Character is the core domain entity representing a player character.
 // Keep this package free of application or infrastructure concerns.
 type Character struct {
-	Name               string      `json:"name"`
-	Race               string      `json:"race"`
-	Class              string      `json:"class"`
-	Level              int         `json:"level"`
-	Str                int         `json:"str"`
-	Dex                int         `json:"dex"`
-	Con                int         `json:"con"`
-	Int                int         `json:"int"`
-	Wis                int         `json:"wis"`
-	Cha                int         `json:"cha"`
-	Background         string      `json:"background"`
-	Proficiency        int         `json:"proficiency"`
-	SkillProficiencies []string    `json:"skill_proficiencies"`
-	MainHand           string      `json:"main_hand,omitempty"`
-	OffHand            string      `json:"off_hand,omitempty"`
-	Armor              string      `json:"armor,omitempty"`
-	Shield             string      `json:"shield,omitempty"`
-	Spellcasting       interface{} `json:"spellcasting"` // Spellcasting data handled in service logic
+	Name               string
+	Race               string
+	Class              string
+	Level              int
+	Str                int
+	Dex                int
+	Con                int
+	Int                int
+	Wis                int
+	Cha                int
+	Background         string
+	Proficiency        int
+	SkillProficiencies []string
+	MainHand           string
+	OffHand            string
+	Armor              string
+	Shield             string
+	Spellcasting       interface{} // Spellcasting data handled in service logic
 	// Data for frontend display
-	StrMod            int `json:"str_mod"`
-	DexMod            int `json:"dex_mod"`
-	ConMod            int `json:"con_mod"`
-	IntMod            int `json:"int_mod"`
-	WisMod            int `json:"wis_mod"`
-	ChaMod            int `json:"cha_mod"`
-	ArmorClass        int `json:"armor_class"`
-	Initiative        int `json:"initiative"`
-	PassivePerception int `json:"passive_perception"`
-	SpellAttackBonus  int `json:"spell_attack_bonus,omitempty"`
+	StrMod            int
+	DexMod            int
+	ConMod            int
+	IntMod            int
+	WisMod            int
+	ChaMod            int
+	ArmorClass        int
+	Initiative        int
+	PassivePerception int
+	SpellAttackBonus  int
 }
 
 // ComputeModifiers computes the ability modifiers from ability scores.
diff --git a/internal/domain/class/model.go b/internal/domain/class/model.go
new file mode 100644
index 0000000..1a90f6b
--- /dev/null
+++ b/internal/domain/class/model.go
@@ -0,0 +1,9 @@
+package classModel
+
+// Class represents character class reference data.
+// This is a pure domain value object with no infrastructure dependencies.
+type Class struct {
+	Name               string
+	SkillProficiencies []string
+	SkillCount         int // How many skills they can choose
+}
diff --git a/internal/domain/spellcasting/rules.go b/internal/domain/spellcasting/rules.go
new file mode 100644
index 0000000..b67a4e3
--- /dev/null
+++ b/internal/domain/spellcasting/rules.go
@@ -0,0 +1,146 @@
+package spellcasting
+
+import "strings"
+
+// GetCasterType returns the caster type for a given class.
+func GetCasterType(class string) CasterType {
+	switch strings.ToLower(class) {
+	case "wizard", "cleric", "druid":
+		return CasterFull
+	case "bard", "sorcerer":
+		return CasterKnown
+	case "paladin", "ranger":
+		return CasterHalf
+	case "warlock":
+		return CasterPact
+	default:
+		return CasterNone
+	}
+}
+
+// GetSpellSlots returns the spell slots for a caster type and level.
+func GetSpellSlots(casterType CasterType, level int) map[int]int {
+	switch casterType {
+	case CasterFull, CasterKnown:
+		return fullCasterSlots(level)
+	case CasterHalf:
+		return halfCasterSlots(level)
+	case CasterPact:
+		return pactCasterSlots(level)
+	default:
+		return map[int]int{}
+	}
+}
+
+// GetCantripsKnown returns the number of cantrips known for a class and level.
+func GetCantripsKnown(class string, level int) int {
+	cantripsTable := map[string][]int{
+		"bard":     {0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
+		"cleric":   {0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
+		"druid":    {0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
+		"sorcerer": {0, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
+		"warlock":  {0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
+		"wizard":   {0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
+	}
+
+	class = strings.ToLower(class)
+	if arr, ok := cantripsTable[class]; ok {
+		if level >= 1 && level < len(arr) {
+			return arr[level]
+		}
+		if level >= len(arr) {
+			return arr[len(arr)-1]
+		}
+	}
+	return 0
+}
+
+// fullCasterSlots returns spell slots for full casters (Wizard, Cleric, Druid, etc.)
+func fullCasterSlots(level int) map[int]int {
+	slots := map[int]map[int]int{
+		1:  {1: 2},
+		2:  {1: 3},
+		3:  {1: 4, 2: 2},
+		4:  {1: 4, 2: 3},
+		5:  {1: 4, 2: 3, 3: 2},
+		6:  {1: 4, 2: 3, 3: 3},
+		7:  {1: 4, 2: 3, 3: 3, 4: 1},
+		8:  {1: 4, 2: 3, 3: 3, 4: 2},
+		9:  {1: 4, 2: 3, 3: 3, 4: 3, 5: 1},
+		10: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2},
+		11: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1},
+		12: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1},
+		13: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1},
+		14: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1},
+		15: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1, 8: 1},
+		16: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1, 8: 1},
+		17: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1},
+		18: {1: 4, 2: 3, 3: 3, 4: 3, 5: 3, 6: 1, 7: 1, 8: 1, 9: 1},
+		19: {1: 4, 2: 3, 3: 3, 4: 3, 5: 3, 6: 2, 7: 1, 8: 1, 9: 1},
+		20: {1: 4, 2: 3, 3: 3, 4: 3, 5: 3, 6: 2, 7: 2, 8: 1, 9: 1},
+	}
+	if s, ok := slots[level]; ok {
+		return s
+	}
+	return map[int]int{}
+}
+
+// halfCasterSlots returns spell slots for half casters (Paladin, Ranger)
+func halfCasterSlots(level int) map[int]int {
+	slots := map[int]map[int]int{
+		1:  {},
+		2:  {1: 2},
+		3:  {1: 3},
+		4:  {1: 3},
+		5:  {1: 4, 2: 2},
+		6:  {1: 4, 2: 2},
+		7:  {1: 4, 2: 3},
+		8:  {1: 4, 2: 3},
+		9:  {1: 4, 2: 3, 3: 2},
+		10: {1: 4, 2: 3, 3: 2},
+		11: {1: 4, 2: 3, 3: 3},
+		12: {1: 4, 2: 3, 3: 3},
+		13: {1: 4, 2: 3, 3: 3, 4: 1},
+		14: {1: 4, 2: 3, 3: 3, 4: 1},
+		15: {1: 4, 2: 3, 3: 3, 4: 2},
+		16: {1: 4, 2: 3, 3: 3, 4: 2},
+		17: {1: 4, 2: 3, 3: 3, 4: 3, 5: 1},
+		18: {1: 4, 2: 3, 3: 3, 4: 3, 5: 1},
+		19: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2},
+		20: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2},
+	}
+	if s, ok := slots[level]; ok {
+		return s
+	}
+	return map[int]int{}
+}
+
+// pactCasterSlots returns spell slots for pact casters (Warlock)
+func pactCasterSlots(level int) map[int]int {
+	slots := map[int]map[int]int{
+		1:  {1: 1},
+		2:  {1: 2},
+		3:  {2: 2},
+		4:  {2: 2},
+		5:  {3: 2},
+		6:  {3: 2},
+		7:  {4: 2},
+		8:  {4: 2},
+		9:  {5: 2},
+		10: {5: 2},
+		11: {5: 3},
+		12: {5: 3},
+		13: {5: 3},
+		14: {5: 3},
+		15: {5: 3},
+		16: {5: 3},
+		17: {5: 4},
+		18: {5: 4},
+		19: {5: 4},
+		20: {5: 4},
+	}
+	if s, ok := slots[level]; ok {
+		return s
+	}
+	return map[int]int{}
+}
diff --git a/internal/domain/spellcasting/spellcasting.go b/internal/domain/spellcasting/spellcasting.go
new file mode 100644
index 0000000..8afb430
--- /dev/null
+++ b/internal/domain/spellcasting/spellcasting.go
@@ -0,0 +1,93 @@
+package spellcasting
+
+// CasterType represents the spellcasting progression type for a class.
+type CasterType string
+
+const (
+	CasterNone  CasterType = "none"
+	CasterFull  CasterType = "full"
+	CasterHalf  CasterType = "half"
+	CasterPact  CasterType = "pact"
+	CasterKnown CasterType = "known"
+)
+
+// Spellcasting represents a character's spellcasting capabilities.
+type Spellcasting struct {
+	CasterType     CasterType
+	KnownSpells    []string
+	PreparedSpells []string
+	SpellSlots     map[int]int // Spell level -> number of slots
+}
+
+// CanCast returns true if this caster type can cast spells.
+func (ct CasterType) CanCast() bool {
+	return ct != CasterNone
+}
+
+// NewSpellcasting creates a new Spellcasting instance for a character.
+func NewSpellcasting(class string, level int) *Spellcasting {
+	casterType := GetCasterType(class)
+	slots := GetSpellSlots(casterType, level)
+
+	return &Spellcasting{
+		CasterType:     casterType,
+		KnownSpells:    []string{},
+		PreparedSpells: []string{},
+		SpellSlots:     slots,
+	}
+}
+
+// LearnSpell adds a spell to the character's known spells if valid.
+// Returns true if the spell was added, false if it was already known.
+func (s *Spellcasting) LearnSpell(spellName string) bool {
+	// Check if spell is already known
+	for _, known := range s.KnownSpells {
+		if known == spellName {
+			return false
+		}
+	}
+
+	s.KnownSpells = append(s.KnownSpells, spellName)
+	return true
+}
+
+// PrepareSpell adds a spell to the character's prepared spells if valid.
+// Returns an error if the spell is not known or already prepared.
+func (s *Spellcasting) PrepareSpell(spellName string) error {
+	// Check if spell is known
+	known := false
+	for _, k := range s.KnownSpells {
+		if k == spellName {
+			known = true
+			break
+		}
+	}
+	if !known {
+		return ErrSpellNotKnown
+	}
+
+	// Check if spell is already prepared
+	for _, p := range s.PreparedSpells {
+		if p == spellName {
+			return ErrSpellAlreadyPrepared
+		}
+	}
+
+	s.PreparedSpells = append(s.PreparedSpells, spellName)
+	return nil
+}
+
+// Domain errors for spellcasting
+var (
+	ErrSpellNotKnown        = &SpellcastingError{"spell is not known"}
+	ErrSpellAlreadyPrepared = &SpellcastingError{"spell is already prepared"}
+)
+
+// SpellcastingError represents a domain error in spellcasting operations.
+type SpellcastingError struct {
+	message string
+}
+
+func (e *SpellcastingError) Error() string {
+	return e.message
+}
diff --git a/internal/domain/spellcasting/spellcasting_test.go b/internal/domain/spellcasting/spellcasting_test.go
new file mode 100644
index 0000000..d65a47f
--- /dev/null
+++ b/internal/domain/spellcasting/spellcasting_test.go
@@ -0,0 +1,37 @@
+package spellcasting
+
+import "testing"
+
+func TestLearnSpell_Duplicate(t *testing.T) {
+	sc := NewSpellcasting("sorcerer", 3) // known-spell caster
+
+	if added := sc.LearnSpell("fireball"); !added {
+		t.Fatalf("expected first learn to add spell")
+	}
+	if added := sc.LearnSpell("fireball"); added {
+		t.Fatalf("expected second learn to be ignored (duplicate)")
+	}
+	if len(sc.KnownSpells) != 1 || sc.KnownSpells[0] != "fireball" {
+		t.Fatalf("known spells mismatch: %#v", sc.KnownSpells)
+	}
+}
+
+func TestPrepareSpell_RequiresKnown(t *testing.T) {
+	sc := NewSpellcasting("wizard", 3) // prepared caster, but domain requires known
+
+	if err := sc.PrepareSpell("magic missile"); err == nil {
+		t.Fatalf("expected error when preparing unknown spell")
+	}
+
+	sc.LearnSpell("magic missile")
+
+	if err := sc.PrepareSpell("magic missile"); err != nil {
+		t.Fatalf("expected prepare to succeed after learning, got %v", err)
+	}
+	if err := sc.PrepareSpell("magic missile"); err == nil {
+		t.Fatalf("expected duplicate prepare to fail")
+	}
+	if len(sc.PreparedSpells) != 1 || sc.PreparedSpells[0] != "magic missile" {
+		t.Fatalf("prepared spells mismatch: %#v", sc.PreparedSpells)
+	}
+}
diff --git a/internal/ports/reference_data.go b/internal/ports/reference_data.go
new file mode 100644
index 0000000..a34aefc
--- /dev/null
+++ b/internal/ports/reference_data.go
@@ -0,0 +1,18 @@
+package ports
+
+import (
+	backgroundModel "modules/dndcharactersheet/internal/domain/background"
+	classModel "modules/dndcharactersheet/internal/domain/class"
+)
+
+// BackgroundRepository provides access to background reference data.
+type BackgroundRepository interface {
+	LoadBackgrounds() ([]backgroundModel.Background, error)
+	FindByName(name string) (*backgroundModel.Background, error)
+}
+
+// ClassRepository provides access to class reference data.
+type ClassRepository interface {
+	LoadClasses() ([]classModel.Class, error)
+	FindByName(name string) (*classModel.Class, error)
+}
diff --git a/internal/ports/spell_repository.go b/internal/ports/spell_repository.go
new file mode 100644
index 0000000..1bb16fa
--- /dev/null
+++ b/internal/ports/spell_repository.go
@@ -0,0 +1,22 @@
+package ports
+
+// Spell represents a D&D spell with its properties.
+type Spell struct {
+	Index    string
+	Name     string
+	Level    int
+	School   string
+	Classes  []string
+	CastTime string
+	Range    string
+	Duration string
+}
+
+// SpellRepository provides access to spell data.
+type SpellRepository interface {
+	// LoadSpells loads all spells from the data source.
+	LoadSpells() ([]Spell, error)
+
+	// FilterByClass filters spells available to a specific class.
+	FilterByClass(spells []Spell, class string) []Spell
+}
diff --git a/internal/spellcasting/assign.go b/internal/spellcasting/assign.go
deleted file mode 100644
index fc931e6..0000000
--- a/internal/spellcasting/assign.go
+++ /dev/null
@@ -1,30 +0,0 @@
-package spellcasting
-
-import (
-	"strings"
-)
-
-// AssignSpellcasting initializes the CharacterSpellcasting struct for a character based on class and level
-func AssignSpellcasting(class string, level int) CharacterSpellcasting {
-	casterType, ok := CasterTypeByClass[strings.ToLower(class)]
-	if !ok {
-		casterType = CasterNone
-	}
-	var slots map[int]int
-	switch casterType {
-	case CasterFull:
-		slots = FullCasterSlots[level]
-	case CasterHalf:
-		slots = HalfCasterSlots[level]
-	case CasterPact:
-		slots = PactCasterSlots[level]
-	default:
-		slots = map[int]int{}
-	}
-	return CharacterSpellcasting{
-		CasterType:     casterType,
-		KnownSpells:    []string{},
-		PreparedSpells: []string{},
-		SpellSlots:     slots,
-	}
-}
diff --git a/internal/spellcasting/model.go b/internal/spellcasting/model.go
deleted file mode 100644
index 2f876dd..0000000
--- a/internal/spellcasting/model.go
+++ /dev/null
@@ -1,137 +0,0 @@
-// GetDefaultSpellSlots returns default spell slots for a class and level
-package spellcasting
-
-import "strings"
-
-type CasterType string
-
-const (
-	CasterNone  CasterType = "none"
-	CasterFull  CasterType = "full"
-	CasterHalf  CasterType = "half"
-	CasterPact  CasterType = "pact"
-	CasterKnown CasterType = "known"
-)
-
-type Spell struct {
-	Name  string
-	Level int
-	Class string
-}
-
-// CharacterSpellcasting holds spellcasting data for a character
-// (to be embedded or referenced in your character model)
-type CharacterSpellcasting struct {
-	CasterType     CasterType
-	KnownSpells    []string
-	PreparedSpells []string
-	SpellSlots     map[int]int // level -> slots
-}
-
-// CasterTypeByClass maps class names to their caster type
-var CasterTypeByClass = map[string]CasterType{
-	"wizard":   CasterFull,
-	"cleric":   CasterFull,
-	"druid":    CasterFull,
-	"bard":     CasterKnown,
-	"sorcerer": CasterKnown,
-	"paladin":  CasterHalf,
-	"ranger":   CasterHalf,
-	"warlock":  CasterPact,
-}
-
-// CantripsKnownByClassAndLevel maps class names to a slice where index is level and value is cantrips known
-var CantripsKnownByClassAndLevel = map[string][]int{
-	"bard":     {0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
-	"cleric":   {0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
-	"druid":    {0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
-	"sorcerer": {0, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6},
-	"warlock":  {0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4},
-	"wizard":   {0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
-}
-
-// GetCantripsKnown returns the number of cantrips known for a class and level
-func GetCantripsKnown(class string, level int) int {
-	class = strings.ToLower(class)
-	if arr, ok := CantripsKnownByClassAndLevel[class]; ok {
-		if level >= 1 && level < len(arr) {
-			return arr[level]
-		}
-		if level >= len(arr) {
-			return arr[len(arr)-1]
-		}
-	}
-	return 0
-}
-
-// FullCasterSlots[level][slotLevel] = slots
-var FullCasterSlots = map[int]map[int]int{
-	1:  {1: 2},
-	2:  {1: 3},
-	3:  {1: 4, 2: 2},
-	4:  {1: 4, 2: 3},
-	5:  {1: 4, 2: 3, 3: 2},
-	6:  {1: 4, 2: 3, 3: 3},
-	7:  {1: 4, 2: 3, 3: 3, 4: 1},
-	8:  {1: 4, 2: 3, 3: 3, 4: 2},
-	9:  {1: 4, 2: 3, 3: 3, 4: 3, 5: 1},
-	10: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2},
-	11: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1},
-	12: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1},
-	13: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1},
-	14: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1},
-	15: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1, 8: 1},
-	16: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1, 8: 1},
-	17: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1},
-	18: {1: 4, 2: 3, 3: 3, 4: 3, 5: 3, 6: 1, 7: 1, 8: 1, 9: 1},
-	19: {1: 4, 2: 3, 3: 3, 4: 3, 5: 3, 6: 2, 7: 1, 8: 1, 9: 1},
-	20: {1: 4, 2: 3, 3: 3, 4: 3, 5: 3, 6: 2, 7: 2, 8: 1, 9: 1},
-}
-
-// HalfCasterSlots[level][slotLevel] = slots (Paladin/Ranger)
-var HalfCasterSlots = map[int]map[int]int{
-	1:  {},
-	2:  {},
-	3:  {1: 2},
-	4:  {1: 3},
-	5:  {1: 4, 2: 2},
-	6:  {1: 4, 2: 2},
-	7:  {1: 4, 2: 3},
-	8:  {1: 4, 2: 3},
-	9:  {1: 4, 2: 3, 3: 2},
-	10: {1: 4, 2: 3, 3: 2},
-	11: {1: 4, 2: 3, 3: 3},
-	12: {1: 4, 2: 3, 3: 3},
-	13: {1: 4, 2: 3, 3: 3, 4: 1},
-	14: {1: 4, 2: 3, 3: 3, 4: 1},
-	15: {1: 4, 2: 3, 3: 3, 4: 2},
-	16: {1: 4, 2: 3, 3: 3, 4: 2},
-	17: {1: 4, 2: 3, 3: 3, 4: 3, 5: 1},
-	18: {1: 4, 2: 3, 3: 3, 4: 3, 5: 1},
-	19: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2},
-	20: {1: 4, 2: 3, 3: 3, 4: 3, 5: 2},
-}
-
-// PactCasterSlots[level][slotLevel] = slots (Warlock)
-var PactCasterSlots = map[int]map[int]int{
-	1:  {1: 1},
-	2:  {1: 2},
-	3:  {1: 2},
-	4:  {2: 2},
-	5:  {3: 2},
-	6:  {3: 2},
-	7:  {4: 2},
-	8:  {4: 2},
-	9:  {5: 2},
-	10: {5: 2},
-	11: {5: 3},
-	12: {5: 3},
-	13: {5: 3},
-	14: {5: 3},
-	15: {5: 3},
-	16: {5: 3},
-	17: {5: 4},
-	18: {5: 4},
-	19: {5: 4},
-	20: {5: 4},
-}
diff --git a/internal/spellcasting/service.go b/internal/spellcasting/service.go
deleted file mode 100644
index eaa9a01..0000000
--- a/internal/spellcasting/service.go
+++ /dev/null
@@ -1,162 +0,0 @@
-package spellcasting
-
-import (
-	"encoding/csv"
-	"fmt"
-	"os"
-	"strconv"
-	"strings"
-)
-
-// FormatCantrips returns a formatted string for cantrips (level 0 spells) from SpellSlots or KnownSpells
-func FormatCantrips(cs *CharacterSpellcasting) string {
-	if cs == nil {
-		return ""
-	}
-	// If cantrips are tracked in SpellSlots (level 0)
-	if slots, exists := cs.SpellSlots[0]; exists {
-		return fmt.Sprintf("Spell slots:\n  Level 0: %d\n", slots)
-	}
-	// If cantrips are tracked in KnownSpells
-	if len(cs.KnownSpells) > 0 {
-		var cantrips []string
-		for _, spellName := range cs.KnownSpells {
-			if strings.Contains(strings.ToLower(spellName), "cantrip") || strings.Contains(strings.ToLower(spellName), "level 0") {
-				cantrips = append(cantrips, spellName)
-			}
-		}
-		if len(cantrips) > 0 {
-			return fmt.Sprintf("Cantrips: %s\n", strings.Join(cantrips, ", "))
-		}
-	}
-	return ""
-}
-
-// Returns a formatted string for a character's spell slots
-func FormatSpellSlots(cs *CharacterSpellcasting, class string, level int) string {
-	if cs == nil {
-		return ""
-	}
-	var sb strings.Builder
-	sb.WriteString("Spell slots:\n")
-	// Print cantrips as Level 0 using GetCantripsKnown if applicable
-	cantrips := GetCantripsKnown(class, level)
-	if cantrips > 0 {
-		sb.WriteString(fmt.Sprintf("  Level 0: %d\n", cantrips))
-	}
-	// Print actual spell slots (levels 1-9)
-	if cs.SpellSlots != nil {
-		for lvl := 1; lvl <= 9; lvl++ {
-			if slots, exists := cs.SpellSlots[lvl]; exists {
-				sb.WriteString(fmt.Sprintf("  Level %d: %d\n", lvl, slots))
-			}
-		}
-	}
-	return sb.String()
-}
-
-// Default spell slots by level
-func GetDefaultSpellSlots(class string, level int) map[int]int {
-	class = strings.ToLower(class)
-	switch class {
-	case "wizard", "cleric", "druid":
-		return FullCasterSlots[level]
-	case "paladin", "ranger":
-		return HalfCasterSlots[level]
-	case "warlock":
-		return PactCasterSlots[level]
-	case "bard", "sorcerer":
-		return FullCasterSlots[level]
-	default:
-		return map[int]int{}
-	}
-}
-
-// LoadSpells loads spells from a CSV file
-func LoadSpells(filename string) ([]Spell, error) {
-	file, err := os.Open(filename)
-	if err != nil {
-		return nil, err
-	}
-	defer file.Close()
-
-	r := csv.NewReader(file)
-	records, err := r.ReadAll()
-	if err != nil {
-		return nil, err
-	}
-
-	var spells []Spell
-	for i, rec := range records {
-		if i == 0 {
-			continue // skip header
-		}
-		level, _ := strconv.Atoi(rec[1])
-		spells = append(spells, Spell{
-			Name:  rec[0],
-			Level: level,
-			Class: rec[2],
-		})
-	}
-	return spells, nil
-}
-
-// FilterSpellsByClass returns spells for a given class
-func FilterSpellsByClass(spells []Spell, class string) []Spell {
-	var filtered []Spell
-	for _, s := range spells {
-		if strings.EqualFold(s.Class, class) {
-			filtered = append(filtered, s)
-		}
-	}
-	return filtered
-}
-
-// CanCastSpells returns true if the caster type is not none
-func CanCastSpells(casterType CasterType) bool {
-	return casterType == CasterFull || casterType == CasterHalf || casterType == CasterPact || casterType == CasterKnown
-}
-
-// LearnSpell attempts to add a spell to the character's known spells
-func LearnSpell(cs *CharacterSpellcasting, spell Spell) string {
-	switch cs.CasterType {
-	case CasterKnown, CasterPact:
-		for _, s := range cs.KnownSpells {
-			if strings.EqualFold(s, spell.Name) {
-				return "Already learned this spell"
-			}
-		}
-		cs.KnownSpells = append(cs.KnownSpells, spell.Name)
-		return "Learned spell " + strings.ToLower(spell.Name)
-	case CasterFull, CasterHalf:
-		return "this class prepares spells and can't learn them"
-	default:
-		return "this class can't cast spells"
-	}
-}
-
-// PrepareSpell attempts to add a spell to the character's prepared spells
-func PrepareSpell(cs *CharacterSpellcasting, spell Spell) string {
-	switch cs.CasterType {
-	case CasterFull, CasterHalf:
-		if spell.Level == 0 {
-			cs.PreparedSpells = append(cs.PreparedSpells, spell.Name)
-			return "Prepared spell " + strings.ToLower(spell.Name)
-		}
-		maxSlot := 0
-		for lvl := range cs.SpellSlots {
-			if lvl > maxSlot {
-				maxSlot = lvl
-			}
-		}
-		if spell.Level > maxSlot {
-			return "the spell has higher level than the available spell slots"
-		}
-		cs.PreparedSpells = append(cs.PreparedSpells, spell.Name)
-		return "Prepared spell " + strings.ToLower(spell.Name)
-	case CasterKnown, CasterPact:
-		return "this class learns spells and can't prepare them"
-	default:
-		return "this class can't cast spells"
-	}
-}
diff --git a/main.go b/main.go
index fdc038f..e73de45 100644
--- a/main.go
+++ b/main.go
@@ -4,12 +4,12 @@ import (
 	"flag"
 	"fmt"
 	apiAdapter "modules/dndcharactersheet/internal/adapters/api"
+	refDataAdapter "modules/dndcharactersheet/internal/adapters/referencedata"
 	spellAdapter "modules/dndcharactersheet/internal/adapters/spellcasting"
 	storageAdapter "modules/dndcharactersheet/internal/adapters/storage"
 	"modules/dndcharactersheet/internal/application"
-	backgroundModel "modules/dndcharactersheet/internal/background"
-	classModel "modules/dndcharactersheet/internal/class"
 	domainChar "modules/dndcharactersheet/internal/domain/character"
+	"modules/dndcharactersheet/internal/domain/spellcasting"
 	"os"
 	"strings"
 )
@@ -68,34 +68,23 @@ func main() {
 			os.Exit(2)
 		}
 
-		// Load backgrounds from JSON
-		backgrounds, err := backgroundModel.LoadBackgrounds("backgrounds.json")
+		// Load backgrounds using repository adapter
+		bgRepo := refDataAdapter.NewJSONBackgroundRepository("backgrounds.json")
+		selectedBgPtr, err := bgRepo.FindByName(*background)
 		if err != nil {
-			fmt.Println("Could not load backgrounds:", err)
+			fmt.Println("Could not find background:", err)
 			os.Exit(1)
 		}
+		selectedBackground := *selectedBgPtr
 
-		var selectedBackground backgroundModel.Background
-		for _, bg := range backgrounds {
-			if strings.EqualFold(bg.Name, *background) {
-				selectedBackground = bg
-				break
-			}
-		}
-
-		classes, err := classModel.LoadClasses("classes.json")
+		// Load classes using repository adapter
+		classRepo := refDataAdapter.NewJSONClassRepository("classes.json")
+		selectedClassPtr, err := classRepo.FindByName(*class)
 		if err != nil {
-			fmt.Println("Could not load classes:", err)
+			fmt.Println("Could not find class:", err)
 			os.Exit(1)
 		}
-
-		var selectedClass classModel.Class
-		for _, cls := range classes {
-			if strings.EqualFold(cls.Name, *class) {
-				selectedClass = cls
-				break
-			}
-		}
+		selectedClass := *selectedClassPtr
 
 		// Creating character using domain layer
 		builder := application.NewCharacterBuilder()
@@ -132,9 +121,17 @@ func main() {
 		// Save character using application service
 		repo := storageAdapter.NewJSONRepository("characters.json")
 		svc := application.NewCharacterService(repo)
+
+		// Assign spellcasting for caster classes
+		spellRepo := spellAdapter.NewCSVSpellRepository("5e-SRD-Spells.csv")
+		spellEng := spellAdapter.NewEngineAdapter(spellRepo)
+		if sc, err := spellEng.AssignSpellcasting(char.Class, char.Level); err == nil && sc != nil {
+			char.Spellcasting = sc
+		}
+
 		// Optionally recalc derived using API enrichers if available
 		api := apiAdapter.NewAPIAdapter("http://localhost:3000/api/2014")
-		svc.WithEnrichers(api, api, api).RecalculateDerived(&char)
+		svc.WithEnrichers(api, api, api).WithSpellcasting(spellEng).RecalculateDerived(&char)
 		err = svc.Create(&char)
 		if err != nil {
 			fmt.Printf("%v\n", err)
@@ -166,8 +163,9 @@ func main() {
 		api := apiAdapter.NewAPIAdapter("http://localhost:3000/api/2014")
 		application.NewCharacterService(repo).WithEnrichers(api, api, api).RecalculateDerived(domainCharPtr)
 
-		// Spellcasting display via adapter formatting (no legacy import in CLI)
-		spellEng := spellAdapter.NewEngineAdapter()
+		// Spellcasting display via adapter formatting
+		spellRepo := spellAdapter.NewCSVSpellRepository("5e-SRD-Spells.csv")
+		spellEng := spellAdapter.NewEngineAdapter(spellRepo)
 
 		// Prints character sheet in CLI using domain values
 		fmt.Printf("Name: %s\n", domainCharPtr.Name)
@@ -205,6 +203,27 @@ func main() {
 		if cantripsStr != "" {
 			fmt.Print(cantripsStr)
 		}
+
+		// Print spellcasting stats if character is a caster
+		if domainCharPtr.Spellcasting != nil {
+			abilityName := svc.GetSpellcastingAbilityName(domainCharPtr.Class)
+			spellSaveDC := svc.CalculateSpellSaveDC(domainCharPtr)
+			fmt.Printf("Spellcasting ability: %s\n", abilityName)
+			fmt.Printf("Spell save DC: %d\n", spellSaveDC)
+			fmt.Printf("Spell attack bonus: +%d\n", domainCharPtr.SpellAttackBonus)
+		}
+
+		// Print known and prepared spells if available
+		if domainCharPtr.Spellcasting != nil {
+			if sc, ok := domainCharPtr.Spellcasting.(*spellcasting.Spellcasting); ok {
+				if len(sc.KnownSpells) > 0 {
+					fmt.Printf("Known spells: %s\n", strings.Join(sc.KnownSpells, ", "))
+				}
+				if len(sc.PreparedSpells) > 0 {
+					fmt.Printf("Prepared spells: %s\n", strings.Join(sc.PreparedSpells, ", "))
+				}
+			}
+		}
 		if domainCharPtr.Name != "Merry Brandybuck" && domainCharPtr.Name != "Pippin Took" && domainCharPtr.Name != "Obi-Wan Kenobi" && domainCharPtr.Name != "Anakin Skywalker" {
 			fmt.Printf("Armor class: %d\n", domainCharPtr.ArmorClass)
 			fmt.Printf("Initiative bonus: %d\n", domainCharPtr.Initiative)
@@ -282,7 +301,8 @@ func main() {
 		// Setup service with enrichers and spellcasting engine
 		repo := storageAdapter.NewJSONRepository("characters.json")
 		apiAdapter := apiAdapter.NewAPIAdapter("http://localhost:3000/api/2014")
-		spellEng := spellAdapter.NewEngineAdapter()
+		spellRepo := spellAdapter.NewCSVSpellRepository("5e-SRD-Spells.csv")
+		spellEng := spellAdapter.NewEngineAdapter(spellRepo)
 		svc := application.NewCharacterService(repo).WithEnrichers(apiAdapter, apiAdapter, apiAdapter).WithSpellcasting(spellEng)
 
 		// Check slot occupation before attempting equip
@@ -381,10 +401,12 @@ func main() {
 			os.Exit(2)
 		}
 
-		// Setup service with enrichers
+		// Setup service with enrichers and spellcasting engine
 		repo := storageAdapter.NewJSONRepository("characters.json")
 		apiAdapter := apiAdapter.NewAPIAdapter("http://localhost:3000/api/2014")
-		svc := application.NewCharacterService(repo).WithEnrichers(apiAdapter, apiAdapter, apiAdapter)
+		spellRepo := spellAdapter.NewCSVSpellRepository("5e-SRD-Spells.csv")
+		spellEng := spellAdapter.NewEngineAdapter(spellRepo)
+		svc := application.NewCharacterService(repo).WithEnrichers(apiAdapter, apiAdapter, apiAdapter).WithSpellcasting(spellEng)
 
 		if _, err := svc.Get(*name); err != nil {
 			fmt.Printf("character \"%s\" not found\n", *name)
@@ -410,7 +432,8 @@ func main() {
 		// Setup service with enrichers and spellcasting engine
 		repo := storageAdapter.NewJSONRepository("characters.json")
 		apiAdapter := apiAdapter.NewAPIAdapter("http://localhost:3000/api/2014")
-		spellEng := spellAdapter.NewEngineAdapter()
+		spellRepo := spellAdapter.NewCSVSpellRepository("5e-SRD-Spells.csv")
+		spellEng := spellAdapter.NewEngineAdapter(spellRepo)
 		svc := application.NewCharacterService(repo).WithEnrichers(apiAdapter, apiAdapter, apiAdapter).WithSpellcasting(spellEng)
 
 		if _, err := svc.Get(*name); err != nil {
